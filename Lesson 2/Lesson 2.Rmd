---
title: "Занятие 2"
output:
  html_document:
    css: style.css
    df_print: paged
---

# Проекты

Большую часть времени мы с вами будем работать в проектах. Проект - это директория (папка), в которой хранятся все материалы той или иной работы. Подробнее о проектах можно будет почитать [здесь](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) или [здесь](https://bookdown.org/ndphillips/YaRrr/projects-in-rstudio.html)

Как создать проект? Войдите во вкладку File => New Project. Во всплывающем меню выберите "New Directory", а в новом всплывающем меню "R Project". Это позволит создать новую папку под проект. **Давайте создадим проект под названием "R Workshop"**.

Основное преимущество проектов заключается в том, что не нужно прописывать полный путь к файлам вашего проекта.

Обычно я использую следующую структуру папок в проектах:

  1. Data - папка, в которой я храню все данные
  2. Scripts - папка,  в которой я храню все скрипты проекта
  3. Results - папка, в которую я выгружаю все промежуточные и финальные результаты проектов.
  
Давайте наполним наш проект:

  1. Создайте все эти папки в вашем новом проекте
  2. Загрузите в папку Data "МСЖ_19_финальная.sav" из Меги
  3. Создайте новый скрипт и сохраните его в папку Scripts под названием "Intro to tidyverse"

# Работа с SPSS данными в RSudio

Данные из SPSS, Stata или SAS загружаются в RStudio помощью пакета haven [см.описание](https://cran.r-project.org/web/packages/haven/index.html), который относится к tidyverse. Поэтому нам не нужно его устанавливать, однако его необходимо "включить" с помощью команды library. 

```{r eval=F}
#install.packages('tidyverse')
library(tidyverse)
library(haven)
```

Основная команда из этого пакета, с которой мы работаем - это read_sav. Посмотрите на ее справку. 
```{r eval=F}
?read_sav
```
Особенно обратите внимание на аргумент "user_na". Что произойдет, если этот аргумент равен FALSE и что произойдет, если этот аргумент будет равен TRUE?

Давайте загрузим данные в переменную data с помощью команды read_sav.
```{r eval=F}
data <- read_sav('Data/МСЖ_19_финальная.sav')
```
Чтобы получить некоторое представление о данных можно воспользоваться следующими командами:
  
  1. View(data) - посмотреть на данные в табличной форме. Очень не рекомендую это делать с большими базами, так как это достаточно медленная команда
  2. glimpse(data) - посмотреть на количество строк, столбцов, названия переменных, их тип, а также на первые несколько ответов.
  3. head(data) - посмотреть на первые пять строк по всем столбцам. В консоли будут отображены только те, что поместились на экран.
  
Попробуйте использовать каждую из этих команд.

```{r eval=F}
View(data)
glimpse(data)
head(data)
```

## Описание лейблов из SPSS.

В целом, работа с лейбл-данными делается с помощью пакета [labelled](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html).

Давайте посмотрим на описание данных с помощью функции look_for().
```{r eval=F}
View(look_for(data, details = T))
```

Так можно получить следующие характеристики по каждой переменной: название, метка, класс, тип, уровни и метки уровней, количество уникальных значений, количество пропущенных и т.д.

# Tidyverse

Tidyverse - это коллекция пакетов, предназначенная для работы с данными. Разрабатывается командой RStudio. Мы пользуемся именно их программным обеспечением сейчас. 
![Что такое Tidyverse](Images/Tidyverse.png)

## Что такое tidy data (чистые данные)?

Есть три правила, в соответствии с которыми нам нужно приводить наши данные:
  
  1. Каждая переменная должна иметь свой столбец
  2. Каждое единица наблюдения должно иметь свою строку
  3. Каждое наблюдение должно иметь свою ячейку
  
![Чистые данные в визуальном представлении](Images/Tidydata.png)

Большая часть данных, с которыми мы работаем, представлена как раз в таком формате.

# Dplyr как грамматика манипулирования данными

Мы начнем работать тремя глаголами dplyr:

  1. filter() - отбор наблюдений
  2. select() - отбор переменных
  3. summarize() - сжатие наблюдений до какой-либо сводки (напр., среднего, стандартного отклонения и так далее)
  
Также мы посмотрим на то, что можно делать с этими глаголами, при применении group_by - группирующей команде.

### Небольшая вставка: два способа работы нескольких функций подряд - изнутри-кнаружи и слева-направо.

До этого мы с вами работали с одним способом написания функций - изнутри-кнаружи. Например,

```{r eval=F}
View(look_for(data, details = T))
```

работает следующим образом. Сначала исполняется команда look_for(), а затем ее результат передается в команду View(). Другой способ появляется вместе c tidyverse. Выглядит он следующим образом:

```{r eval=F}
look_for(data, details = T) %>% 
  View()
```

Что здесь написано:
  
  1. Выполни команду look_for(data, details = T)
  2. Передай ее результаты дальше (за эту часть отвечает %>%)
  3. Выполни команду View() над тем, что было передано раньше

## [Фильтр, filter](https://dplyr.tidyverse.org/reference/filter.html)

### Один фильтр

Давайте научимся извлекать разные группы студентов для работы.
Например, попробуем извлечь из базы только первокурсников бакалавриата.
Чтобы это сделать нам нужно найти переменную, в которой записан курс обучения. Мы можем это сделать с помощью уже упоминаемой функции look_for().

Запустите следующую команду:
```{r eval=F}
look_for(data, details = T) %>% 
  View()
```
Наберите в поиске "бакалав" следующим образом (см. скриншот ниже)
![Поиск "бакалав" в описании данных](Images/Search.png)
Мы нашли переменную **VV1**, которая отвечает за курс обучения.
Давайте теперь посмотрим на то, как она закодирована.
```{r eval=F}
val_labels(data$VV1) #Знак $ помогает извлекать переменную из базы данных. Подр., см. курс на stepik
```

Первый курс закодирован под цифрой 1. Воспользуемся этим для того, чтобы написать наш первый фильтр.
```{r eval=F}
data %>% 
  filter(VV1 == 1) #В фильтрах всегда используются логические операции. Обратите внимание на то, что проверка логическая проверка делается с помощью двух знаков равно (==).
```
Давайте сохраним результат и посмотрим, в чем его отличие от изначальной базы.
```{r eval=F}
data_1st_course <- data %>% 
  filter(VV1 == 1)
```

**Некоторые полезные команды для работы с фильтрами:**

  1. ==, >, <, >=, <=, != (не равно)
  2. НАЗВАНИЕ_ПЕРЕМЕННОЙ %in% ВЕКТОР_ЗНАЧЕНИЙ - используем, если хотим перечислить несколько случаев. Напр. так можно получить первый, третий курс бакалавриата и первый курс магистратуры
```{r eval=F}
data %>% 
  filter(VV1 %in% c(1, 3, 8))
```
  3. !is.na(НАЗВАНИЕ_ПЕРЕМЕННОЙ) - используем, если хотим убрать пропущенные значения.
```{r eval=F}
data %>% 
  filter(!is.na(VV1))
```

### Несколько фильтров

Дополнить фильтры можно просто через запятую. Например, давайте выберем студентов первого курса бакалавриата, которые не относятся к иностранцам. Это делается следующим образом:
```{r eval=F}
data %>% 
  filter(VV1 == 1, VV0==0)
```

## [Выбор переменной, select](https://dplyr.tidyverse.org/reference/select.html)

### Выбор одной или нескольких переменных с помощью перечисления их названий

Переменные можно выбрать просто написав их название в функции select(). Если нужно выбрать несколько переменных, то их можно написать через запятую. 
```{r eval=F}
data %>% 
  select(VV1, VV0, USL1s2_r1, USL1s2_r2, USL1s2_r3, USL1s2_r4, SERV1_1, SERV1_2, SERV1_3)
```

### Использование одного помощника, helper для выбора переменных

Переменные можно выбирать и с помощью следующих функций внутри select():

  1. starts_with("ТЕКСТ_С_КОТОРОГО_НАЧИНАЮТСЯ_ПЕРЕМЕННЫЕ") - с помощью этой функции можно указать начало текста, по которому нужно найти интересующие нас переменные.
```{r eval=F}
data %>% 
  select(starts_with("VV"))
```
  2. ends_with("ТЕКСТ_КОТОРЫМ_ЗАКАНЧИВАЮТСЯ_НУЖНЫЕ_ПЕРЕМЕННЫЕ") - с помощью этой функции можно указать конец текста, по которому нужно найти интересующие нас переменные.
```{r eval=F}
data %>% 
  select(ends_with("_r1"))
```
  3. contains("ТЕКСТ_КОТОРЫЙ_СОДЕРЖИТСЯ_В_НАЗВАНИИ_НУЖНЫХ_ПЕРЕМЕННЫХ") - с помощью этой функции можно указать текст, по которому нужно найти интересующие нас переменные.
```{r eval=F}
data %>% 
  select(contains("SERV"))
```
  4. num_range("ТЕКСТ_КОТОРЫЙ_СОДЕРЖИТСЯ_В_НАЗВАНИИ_ПЕРЕМЕННОЙ", ВЕКТОР_С_ЦИФРАМИ) - с помощью этой функции можно указать текст и цифры, по которым нужно найти интересующие нас переменные (напр., VV0, VV1 или SERV1_1, SERV1_2.
```{r eval=F}
data %>% 
  select(num_range("USL1s2_r", 1:3))
```

### Использование нескольких помощников, helper для выбора переменных

Можно использовать несколько помощников одновременно для выбора переменных. Обратите внимание, что тогда выберутся все перечисленные переменные.
```{r eval=F}
data %>% 
  select(starts_with("VV"), contains("SERV"), num_range("USL1s2_r", 1:4))
```

Если же вы хотите использовать несколько помощников для того, чтобы выбрать определенную группу переменных, то необходимо использовать логические операторы. Напр., вас интересуют переменные, которые начинаются на "SERV" И заканчиваются на "1". Для этого вы можете использовать логический оператор "&" (И).
```{r eval=F}
data %>% 
  select(starts_with("SERV") & ends_with("1"))
```

О каких еще логических операторах нужно знать:

  1. & (И)
  2. | (ИЛИ)
  3. ! (НЕ)

## [Сводка по переменным, summarize или summarise](https://dplyr.tidyverse.org/reference/summarise.html)

Чтобы получить ту или иную сводку по нашим наблюдениям, необходимо использовать summarize(). В summarize есть множество функций, которые позволяют получить сводки. Приведу некоторые из них:

  1. Меры центральной тенденции: mean() - среднее, median() - медиана
  2. Меры вариативности: sd() - станд.отклон., IQR() - межквартильный размах, mad() - отклонение от медианы
  3. Меры размаха: min() - минимальное значение, max() - максимальное, quantile() - процентили
  4. Количества: n() - количество наблюдений, n_distinct() - количество уникальных наблюдений
  
Давайте начнем с простого примера. Попробуем получить количество человек в данных
```{r eval=F}
data %>% 
  summarize(n())
```

Теперь попробуем получить средние, стандартные отклонения и количество человек по переменной USL1s2_r1 - "Оценка сопровождения обр. процесса - Условия для аудиторного обучения"

```{r eval=F}
data %>% 
  summarize(
    mean = mean(USL1s2_r1), 
    sd = sd(USL1s2_r1),
    n = n()
  )
```

Что случилось? Дело в том, что в этой переменной есть пропущенные значения. Если R видит пропущенные значения, то тогда он не выдает оценку. Что можно с этим сделать? Посмотрите на справку по функции mean()
```{r eval=F}
?mean()
```

Применим полученные знания из этой справки.
```{r eval=F}
data %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )
```
Кхм, произошло что-то подозрительное. Откуда такое большое стандартное отклонение? Давайте посмотрим на эту переменную с помощью look_for() или через val_labels().
```{r eval=F}
val_labels(data$USL1s2_r1)
```
Мы видим, что помимо 1-5, также есть и 99. Судя по всему в нашей базе эта переменная не была закодирована как пропущенная. Давайте отфильтруем базу, убрав наблюдения, в которых эта переменная принимает значение "99".

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )
```

Теперь получилось гораздо лучше! Обратите внимание, как мы использовали несколько выражений подряд. Сначала мы сказали, что есть база под название data. Затем мы попросили эту базу отфильтровать, а потом по этой отфильтрованной базе мы попросили сделать сводку. В этом одна из самых сильных сторон Dplyr - возможность объединять несколько команд в одну выражение.

## [+ Вспомогательный глагол "Сгруппировать по", groupby()](https://dplyr.tidyverse.org/reference/group_by.html)

Если бы мы хотели теперь получить оценку по USL1s2_r1 - "Оценка сопровождения обр. процесса - Условия для аудиторного обучения" по каждому курсу обучения, то мы могли бы последовательно применить несколько фильтров.
```{r eval=F}
data %>% 
  filter(VV1 == 1) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )

data %>% 
  filter(VV1 == 2) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )
```

И так далее. 

Однако есть куда более удобная команда - group_by(), которая позволяет сделать базу данных сгруппированной. Это означает, что все операции, которые вы будете делать после применения группирования, будут применяться не на всю базу, а на каждую из групп. У этой функции есть много клевых применений, но пока мы остановимся только на одном - на использовании команды group_by() вместе со сводками.

### Использования одного группирования

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )
```

Обратите внимание на то, что мы в нескольких колонках получили стандартное отклонение равное NA. Почему так?

### Использование нескольких групп

Если вы хотите получить более гранулированные группы, то вы можете их дальше перечислять в команде group_by()

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  )
```

### Разгруппировка

Если с полученными результатами вы захотите что-то делать не на уровне групп, а на уровне базы, то тогда вам следует применить команду ungroup().

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  ) %>% 
  ungroup()
```
