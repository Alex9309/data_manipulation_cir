---
title: "Занятие 4"
output:
  html_document:
    css: style.css
    df_print: paged
---

# Что мы узнали и чему научились на данный момент:

  1. Основы работы с R: Типы и структуры данных, проекты, пакеты и т.д.
  2. Основы работы с Dplyr и Tidyr: filter, select, summarize, arrange, mutate, slice, group_by
  
# Темы сегодняшнего дня:

  1. Пивотирование
  2. Работа с факторами
  3. Работа со строками

# Пивотирование

Пивотирование - это процедура перевода таблиц из "широкого" в "длинный" формат, и наоборот.
"Широкий" формат отсылает к тому, что данные разнесены по столбцам, а "длинный формат" - по строкам. 

Возьмем в качестве примера функцию из второго занятия, где мы делали две группировки считали три показателя по этим группам. 

```{r eval=F}
#install.packages('tidyverse')
library(tidyverse)
library(labelled)
library(haven)

data <- read_sav('Data/МСЖ_19_финальная.sav')

data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  ) 
```

Если бы нам нужно было бы перевести данные в более "длинный" формат. Допустим, мы хотим, чтобы был только один столбец, в котором находятся все значения, и средние, стандартные отклонения, и количество опрошенных. 

Мы можем это сделать с помощью команды pivot_longer. Закажите справку по этой команде и посмотрите, как она работает. 

В pivot_longer() есть один обязательный аргумент - cols, в котором мы указываем, какие колонки мы бы хотели перевести в такой формат. Давайте попробуем запустить функцию по всей полученной таблице.

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  ) %>% 
  pivot_longer(
    c(mean, sd, n)
  )
```

Эта функция трансформировала эти три колонки в две: name (в которой записано название колонки) и value (в которой записано значение по этой таблице).

Теперь, если бы мы хотели, чтобы эти значения были разбиты по курсам, то есть увеличить количество столбцов, нам нужно перевести данные в "широкий" формат. Мы можем это сделать с помощью функции pivot_wider(). Закажите справку по этой команде и посмотрите, как она работает. 

В pivot_wider() есть один два обязательных аргумента - names_from, values_from, в которых мы указываем, откуда брать названия столбцов и их значения соответственно.

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  ) %>% 
  pivot_longer(
    c(mean, sd, n)
  ) %>% 
  pivot_wider(
    names_from = VV1,
    values_from = value
  )
```

Мы получили то, что хотели, однако есть проблема в столбцах. Мы получали не labels, а values в колонках. Что можно с этим сделать? Например, можно использовать функцию to_factor(). Закажите справку по этой команде и посмотрите, как она работает.  

```{r eval=F}
data %>% 
  filter(USL1s2_r1 != 99) %>% 
  group_by(VV1, VV0) %>% 
  summarize(
    mean = mean(USL1s2_r1, na.rm = T), 
    sd = sd(USL1s2_r1, na.rm = T),
    n = n()
  ) %>% 
  mutate(VV1 = to_factor(VV1)) %>%
  pivot_longer(
    c(mean, sd, n)
  ) %>% 
  pivot_wider(
    names_from = VV1,
    values_from = value
  )
```

# Работа с факторами

Как вы уже знаете, R представляет категориальные данные с помощью факторов. Давайте посмотрим что можно делать с помощью одного из пакетов, предназначенного для работы с факторами, [forcats](https://forcats.tidyverse.org/). Обратите внимание, что когда мы прочитываем данные из SPSS, то мы изначально изначально получаем не факторы. 

Давайте переведем все переменные в факторы с помощью mutate + across + to_factor.

```{r, eval=F}
data %>% 
  mutate(across(everything(), ~to_factor(.x))) -> data
```

Пакет forcats позволяет много что делать с факторами:

  1. Исследовать наполненность категорий
  2. Объединять несколько факторов в одну переменную
  3. Менять порядок факторов (полезно в отображении и для графиков)
  4. Перекодировать уровни факторов
  5. Добавлять или исключать уровни факторов
  
Шпаргалка по этому пакету доступна [по ссылке](https://github.com/rstudio/cheatsheets/raw/master/factors.pdf)

Рассмотрим несколько примеров, связанных с перекодировкой факторов. Если мы хотим перекодировать факторы, то можно использовать fct_recode() внутри mutate(). В целом, fct_recode() работает следующим образом. fct_recode(ПЕРЕМЕННАЯ, НОВОЕ_НАЗВАНИЕ = "СТАРОЕ_НАЗВАНИЕ_В_КАВЫЧКАХ")

```{r, eval=F}
data %>% 
  mutate(
    VV1 = fct_recode(VV1,
      `1 курс бакалавриата` = "1 курс бакалавриата/специалитета", 
      `2 курс бакалавриата` = "2 курс бакалавриата/специалитета", 
      `3 курс бакалавриата` = "3 курс бакалавриата/специалитета", 
      `4 курс бакалавриата` = "4 курс специалитета", 
      `4 курс бакалавриата` = "5 курс специалитета", 
      `4 курс бакалавриата` = "6 курс специалитета", 
    )
  ) %>% 
  group_by(VV1) %>% 
  summarize(n())
```ы

Обратите внимание, что я пишу новое название в "лапках", ``. Лапки нужны для того, чтобы писать названия переменных на русском, использовать пробелы и вообще значительно расширить ваши возможности в названиях. 

Если посмотреть на этот пример, то можно заметить, что мы несколько раз повторяли "4 курс". Это можно было бы сделать с помощью fct_collapse(), который схлопывает несколько значений в одно. 

```{r, eval=F}
data %>% 
  mutate(
    VV1 = fct_recode(VV1,
                     `1 курс бакалавриата` = "1 курс бакалавриата/специалитета", 
                     `2 курс бакалавриата` = "2 курс бакалавриата/специалитета", 
                     `3 курс бакалавриата` = "3 курс бакалавриата/специалитета", 
    ),
    VV1 = fct_collapse(VV1, 
                       `4 курс бакалавриата` = c("4 курс специалитета", "5 курс специалитета", "6 курс специалитета"))
  ) %>% 
  group_by(VV1) %>% 
  summarize(n())
```

Еще одна функция, связанная с перекодированием, позволяет трансформировать ненужные факторы в "другое". Эта функция - fct_other(). Есть несколько способов, какими можно уточнить, что вы хотите оставить или убрать. Воспользуемся одним из них. Сохраним только 1, 2 и 3 курсы.

```{r, eval=F}
data %>% 
  mutate(
    VV1 = fct_other(VV1,
                    keep = c(
                      '1 курс бакалавриата/специалитета',
                      '2 курс бакалавриата/специалитета',
                      '3 курс бакалавриата/специалитета'),
                    other_level = 'Другое')
    
  ) %>% 
  group_by(VV1) %>% 
  summarize(n())
```

Наконец, еще одна очень полезная функция, которая есть в forcats - это анонимизация факторов с помощью fct_anon(). Посмотрите по ней справку и попробуйте применить на CommonStudent.

```{r, eval=F}
data %>% 
  mutate(
    CommonStudent_anon = fct_anon(CommonStudent)
  ) %>% 
  select(CommonStudent_anon)
```

# Работа со строками в R

В tidyverse для работы со строками используют пакет [stringr](https://stringr.tidyverse.org/). Шпаргалка по этому пакету находится [по ссылке](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf).

# Домашнее задание

Все следующее занятие будет посвящено практической работе, поэтому повторите все темы, которые мы проходили и постарайтесь выполнить все домашние задания, которые еще не успели выполнить. Нового домашнего задания не будет.

